%% Object class
classdef GlobalController < handle
   properties
       environment;
       redDepositLocation;
       greenDepositLocation;
       blueDepositLocation;
       redTargetLocations;
       greenTargetLocations;
       blueTargetLocations;
       camera;
       robot;
       hand;
       objects;
   end
   
   methods
       function self = GlobalController(environment, camera)  
           self.environment = environment;
           self.camera = camera;
       end
       %% Add Environment
       function AddEnvironment(self, environment)
           self.environment = environment;
       end
%        %% Add Robot
%        function AddRobot(self, robot)
%           self.robot(numel(self.robot)+1) = robot; 
%        end
       %% Run Simulation
       function Run(self)
           startingPose = self.environment.robot.model.base();
           
           disp('Calculating the Pick Up and Deposit Locations');
           
           % Calculate Pick Up and Deposit locations
           self.camera.LocateObjects();
           
           
           
           
                     
           % NEED TO FIND WAY OF DOING THIS USING THE COLOURS OF EACH
           % TARGET OBJECT
           self.redDepositLocation(:,:,1) = eye(4) * transl(self.camera.globalCentroids(1,1), self.camera.globalCentroids(1,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(1)));
           self.redTargetLocations(:,:,1) = eye(4) * transl(self.camera.globalCentroids(4,1), self.camera.globalCentroids(4,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(4)));
           self.greenDepositLocation(:,:,1) = eye(4) * transl(self.camera.globalCentroids(2,1), self.camera.globalCentroids(2,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(2)));
           self.greenTargetLocations(:,:,1) = eye(4) * transl(self.camera.globalCentroids(5,1), self.camera.globalCentroids(5,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(5)));
           self.greenTargetLocations(:,:,2) = eye(4) * transl(self.camera.globalCentroids(7,1), self.camera.globalCentroids(7,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(7)));
           self.blueDepositLocation(:,:,1) = eye(4) * transl(self.camera.globalCentroids(3,1), self.camera.globalCentroids(3,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(3)));
           self.blueTargetLocations(:,:,1) = eye(4) * transl(self.camera.globalCentroids(6,1), self.camera.globalCentroids(6,2), 0.8911) * trotz(deg2rad(self.camera.globalOrientations(6)));
           
           % NEED TO FIX THE CODE ABOVE SO THAT IT IS NOT HARD CODED
           
 

           
           
           % Drive to pick up location on linear slide
           for i = 1:1:size(self.redTargetLocations, 3)
               shortestDistance = 5;
               objectIndex = 1;
               
               targetPosition = self.redTargetLocations(1,4,i);
               self.environment.robot.MoveToTargetLinearRail(targetPosition);
               
               % Collect Object
               targetPose = self.redTargetLocations(:,:,i);
               
               for j = 1:size(self.environment.targets, 2)
                   distance = self.DistanceBetweenPoses(targetPose, self.environment.targets{j}.pose);
                   if distance < shortestDistance
                       objectIndex = j;
                       shortestDistance = distance;
                   end
               end
                              
               if targetPose(2,4) < self.environment.robot.model.base(2,4)
                   waypoint = deg2rad([-90, 60, 65, -35, 0]);
                   self.MoveRobotArmJointAngles(waypoint);
                   targetPose = self.redTargetLocations(:,:,i) * trotx(pi) * trotz(deg2rad(80));

               else
                   waypoint = deg2rad([90, 60, 65, -35, 0]);
                   self.MoveRobotArmJointAngles(waypoint);
                   targetPose = self.redTargetLocations(:,:,i) * trotz(deg2rad(80)) * trotx(pi);
               end

               self.MoveRobotArm(targetPose);
               
               disp('Target Pose: ');
               disp(targetPose);
               pose = self.environment.robot.model.fkine(self.environment.robot.model.getpos())
               error = targetPose - pose
               
               self.environment.robot.object = self.environment.targets{objectIndex};
               
               % Return to deposit location
               self.MoveRobotArmJointAngles(waypoint);
               self.MoveRobotArmJointAngles(self.environment.robot.jointAngles);

               targetPosition = self.redDepositLocation(1,4,1);
               self.environment.robot.MoveToTargetLinearRail(targetPosition);

               % Drop object
               targetPose = self.redDepositLocation(:,:,1);
               self.MoveRobotArm(targetPose * trotx(pi));
               
               pose = self.environment.robot.model.fkine(self.environment.robot.model.getpos())
               
               self.environment.robot.object = EnvironmentObject.empty;
               
               self.MoveRobotArmJointAngles(self.environment.robot.jointAngles);   
           end
           
           
           
           self.hand = EnvironmentObject('Type', 'misc', 'ModelPath', 'hand.ply', 'Pose', transl(-0.2, 0.45, self.environment.foundation.dimensions(1,3)+0.4), 'Dimensions', [0.1734 0.0123 0.0124], 'GeneralColour', 'y');
           self.hand.SetPose(self.hand.pose * trotz(-pi/2));
           self.hand.Display();
           
           self.environment.AddObject(self.hand);
           

           
           
           
           
           for i = 1:1:size(self.greenTargetLocations, 3)
               shortestDistance = 5;
               objectIndex = 1;
               
               targetPosition = self.greenTargetLocations(1,4,i);
               self.environment.robot.MoveToTargetLinearRail(targetPosition);
               
               % Collect Object
               targetPose = self.greenTargetLocations(:,:,i);
               
               for j = 1:size(self.environment.targets, 2)
                   distance = self.DistanceBetweenPoses(targetPose, self.environment.targets{j}.pose);
                   if distance < shortestDistance
                       objectIndex = j;
                       shortestDistance = distance;
                   end
               end
               
               if targetPose(2,4) < self.environment.robot.model.base(2,4)
                   waypoint = deg2rad([-90, 60, 65, -35, 0]);
                   self.MoveRobotArmJointAngles(waypoint);
                   targetPose = self.greenTargetLocations(:,:,i) * trotx(pi) * trotz(deg2rad(80));

               else
                   waypoint = deg2rad([90, 60, 65, -35, 0]);
                   self.MoveRobotArmJointAngles(waypoint);
                   targetPose = self.greenTargetLocations(:,:,i) * trotz(deg2rad(80)) * trotx(pi);

               end

               self.MoveRobotArm(targetPose);
                      
               disp('Target Pose: ');
               disp(targetPose);
               pose = self.environment.robot.model.fkine(self.environment.robot.model.getpos())
               error = targetPose - pose
               
               self.environment.robot.object = self.environment.targets{objectIndex};
               
               % Return to deposit location
               self.MoveRobotArmJointAngles(waypoint);
               self.MoveRobotArmJointAngles(self.environment.robot.jointAngles);

               targetPosition = self.greenDepositLocation(1,4,1);
               self.environment.robot.MoveToTargetLinearRail(targetPosition);

               % Drop object
               targetPose = self.greenDepositLocation(:,:,1);
               self.MoveRobotArm(targetPose * trotx(pi));
               
               pose = self.environment.robot.model.fkine(self.environment.robot.model.getpos())
               
               self.environment.robot.object = EnvironmentObject.empty;
               
               self.MoveRobotArmJointAngles(self.environment.robot.jointAngles);
           end
           
           
           

           for i = 1:1:size(self.blueTargetLocations, 3)
               shortestDistance = 5;
               objectIndex = 1;
               targetPosition = self.blueTargetLocations(1,4,i);
               self.environment.robot.MoveToTargetLinearRail(targetPosition);
               
               % Collect Object
               targetPose = self.blueTargetLocations(:,:,i);
               
               for j = 1:size(self.environment.targets, 2)
                   distance = self.DistanceBetweenPoses(targetPose, self.environment.targets{j}.pose);
                   if distance < shortestDistance
                       objectIndex = j;
                       shortestDistance = distance;
                   end
               end
               
               if targetPose(2,4) < self.environment.robot.model.base(2,4)
                   waypoint = deg2rad([-90, 60, 65, -35, 0]);
                   self.MoveRobotArmJointAngles(waypoint);
                   targetPose = self.blueTargetLocations(:,:,i) * trotx(pi) * trotz(deg2rad(80));

               else
                   waypoint = deg2rad([90, 60, 65, -35, 0]);
                   self.MoveRobotArmJointAngles(waypoint);
                   targetPose = self.blueTargetLocations(:,:,i) * trotz(deg2rad(80)) * trotx(pi);

               end

               self.MoveRobotArm(targetPose);
                      
               disp('Target Pose: ');
               disp(targetPose);
               pose = self.environment.robot.model.fkine(self.environment.robot.model.getpos())
               error = targetPose - pose
               
               self.environment.robot.object = self.environment.targets{objectIndex};
               
               % Return to deposit location
               self.MoveRobotArmJointAngles(waypoint);
               self.MoveRobotArmJointAngles(self.environment.robot.jointAngles);

               targetPosition = self.blueDepositLocation(1,4,1);
               self.environment.robot.MoveToTargetLinearRail(targetPosition);

               % Drop object
               targetPose = self.blueDepositLocation(:,:,1);
               self.MoveRobotArm(targetPose * trotx(pi));
               
               pose = self.environment.robot.model.fkine(self.environment.robot.model.getpos())
               
               self.environment.robot.object = EnvironmentObject.empty;
               
               self.MoveRobotArmJointAngles(self.environment.robot.jointAngles);
           end
                      
           
       end
       %% Initialise Simulation
       % Display the environment and calculate all the necessary target and
       % deposit locations and store them in appropriate variables
       function Init(self)
           self.environment.Display();
           self.camera.DisplayCamera();
           
           for i = 1:size(self.environment.targets,2)
               self.camera.AddObject(self.environment.targets{i});
           end
           
           for i = 1:size(self.environment.deposit,2)
               self.camera.AddObject(self.environment.deposit{i});
           end
           
       end
       %% Init Environment
       function InitEnvironment(self)
           
       end
       
       %% Distance between poses
       function dist = DistanceBetweenPoses(self, pose1, pose2)
            dist = sqrt(((pose1(1,4)-pose2(1,4))^2 + (pose1(2,4)-pose2(2,4))^2 + (pose1(3,4)-pose2(3,4))^2));
       end
       
       
       %% Move Arm
        function MoveRobotArm(self, targetPose)
            q0 = self.environment.robot.model.getpos;

            %EEPose1 = targetPose
            %q1 = self.GenerateTargetJointAngles2(self.model.base, EEPose1)
            
            q1 = self.environment.robot.model.ikcon(targetPose, q0);
            
            %q1(4) = pi/2 - (q1(2) + q1(3));
            
            steps = 50;
            s = lspb(0,1,steps);
            qMatrix = nan(steps,5);

            for i = 1:steps
                qMatrix(i,:) = (1-s(i))*q0 + s(i)*q1;
            end

            for i = 1:steps
               self.environment.robot.stop = 0;
               if 0 < size(self.environment.checkObjects, 2)
                   for j = 1:size(self.environment.checkObjects, 2)
                       checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                       if checkCurtain == 1
                          self.environment.robot.stop = 1;
                          break;
                       end
                   end
               end
               
               while (self.environment.robot.stop == 1)
                   disp('Robot Stopped');
                   self.environment.robot.stop = 0;
                   for j = 1:size(self.environment.checkObjects, 2)
                       checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                       if checkCurtain == 1
                          self.environment.robot.stop = 1;
                          break;
                       end
                   end
                   pause(0.01);
               end
                
               self.environment.robot.model.animate(qMatrix(i, :));
               
               for k = 1:1:size(self.environment.robot.object, 2)
                    % Set the desired object pose to be at the end effector
                    objectPose = self.environment.robot.model.fkine(self.environment.robot.model.getpos());

                    % Update the object's position
                    self.environment.robot.object(k).SetPose(objectPose);
               end
               
               drawnow();
            end
        end
        
        %% Move Arm Joint Angles
        function MoveRobotArmJointAngles(self, targetAngles)
            q0 = self.environment.robot.model.getpos;

            %q1 = self.GenerateTargetJointAngles2(self.model.base, EEPose1)
            
            q1 = targetAngles;
            
            %q1(4) = pi/2 - (q1(2) + q1(3));
            
            steps = 50;
            s = lspb(0,1,steps);
            qMatrix = nan(steps,5);

            for i = 1:steps
                qMatrix(i,:) = (1-s(i))*q0 + s(i)*q1;
            end

            for i = 1:steps
               self.environment.robot.stop = 0;
               if 0 < size(self.environment.checkObjects, 2)
                   for j = 1:size(self.environment.checkObjects, 2)
                       checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                       if checkCurtain == 1
                          self.environment.robot.stop = 1;
                          break;
                       end
                   end
               end
               
               while (self.environment.robot.stop == 1)
                   disp('Robot Stopped');
                   self.environment.robot.stop = 0;
                   for j = 1:size(self.environment.checkObjects, 2)
                       checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                       if checkCurtain == 1
                          self.environment.robot.stop = 1;
                          break;
                       end
                   end
                   pause(0.01);
               end
                
               self.environment.robot.model.animate(qMatrix(i, :));
               
               for k = 1:1:size(self.environment.robot.object, 2)
                    % Set the desired object pose to be at the end effector
                    objectPose = self.environment.robot.model.fkine(self.environment.robot.model.getpos());

                    % Update the object's position
                    self.environment.robot.object(k).SetPose(objectPose);
               end
               
               drawnow();
            end
        end
        
        %% Move linear rail to target location
        function MoveToTargetLinearRail(self, x)
           disp("X is : " + x);
           steps = 50;
           distanceToTravel = x - self.model.base(1,4);
            
           if (((self.environment.robot.linearRailPose(1,4) - self.environment.robot.linearRail.modelMidPoint(1,1) + self.environment.robot.baseWidth/2) <= x) && (x + self.environment.robot.baseWidth/2 <= (self.environment.robot.linearRailPose(1,4) - self.environment.robot.linearRail.modelMidPoint(1,1) + self.environment.robot.linearRailTravelDist)))
              increment = distanceToTravel/steps;
              for i = 1:steps
                   self.environment.robot.stop = 0;
                   if 0 < size(self.environment.checkObjects, 2)
                       for j = 1:size(self.environment.checkObjects, 2)
                           checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                           if checkCurtain == 1
                              self.environment.robot.stop = 1;
                              break;
                           end
                       end
                   end

                   while (self.environment.robot.stop == 1)
                       disp('Robot Stopped');
                       self.environment.robot.stop = 0;
                       for j = 1:size(self.environment.checkObjects, 2)
                           checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                           if checkCurtain == 1
                              self.environment.robot.stop = 1;
                              break;
                           end
                       end
                       pause(0.01);
                   end

                  self.environment.robot.model.base(1, 4) = self.environment.robot.model.base(1,4) + increment;
                  self.environment.robot.model.animate(self.environment.robot.model.getpos);
                  
                   for k = 1:1:size(self.environment.robot.object, 2)
                        % Set the desired object pose to be at the end effector
                        objectPose = self.environment.robot.model.fkine(self.environment.robot.model.getpos());

                        % Update the object's position
                        self.environment.robot.object(k).SetPose(objectPose);
                   end
                  
                  drawnow();
              end
              disp(1);
           end
           
           if (x < (self.linearRailPose(1,4) - self.linearRail.modelMidPoint(1,1) + self.baseWidth/2))
              distance = (self.linearRailPose(1, 4) - self.linearRail.modelMidPoint(1,1) + self.baseWidth/2) - self.model.base(1,4);
              increment = distance/steps;
              
              for i = 1:steps
                   self.environment.robot.stop = 0;
                   if 0 < size(self.environment.checkObjects, 2)
                       for j = 1:size(self.environment.checkObjects, 2)
                           checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                           if checkCurtain == 1
                              self.environment.robot.stop = 1;
                              break;
                           end
                       end
                   end

                   while (self.environment.robot.stop == 1)
                       disp('Robot Stopped');
                       self.environment.robot.stop = 0;
                       for j = 1:size(self.environment.checkObjects, 2)
                           checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                           if checkCurtain == 1
                              self.environment.robot.stop = 1;
                              break;
                           end
                       end
                       pause(0.01);
                   end
                  
                  
                  self.environment.robot.model.base(1, 4) = self.environment.robot.model.base(1,4) + increment;
                  self.environment.robot.model.animate(self.environment.robot.model.getpos);
                  
                  for k = 1:1:size(self.environment.robot.object, 2)
                    % Set the desired object pose to be at the end effector
                    objectPose = self.environment.robot.model.fkine(self.environment.robot.model.getpos());

                    % Update the object's position
                    self.environment.robot.object(k).SetPose(objectPose);
                  end
                  
                  drawnow();
              end
              disp(2);
           end
           
           if (x + self.baseWidth/2 > (self.linearRailPose(1,4) - self.linearRail.modelMidPoint(1,1) + self.linearRailTravelDist))
              distance = (self.linearRailPose(1, 4) - self.linearRail.modelMidPoint(1,1) + self.linearRailTravelDist + self.baseWidth/2) - self.model.base(1,4);
              increment = distance/steps;
              
              for i = 1:steps
                   self.environment.robot.stop = 0;
                   if 0 < size(self.environment.checkObjects, 2)
                       for j = 1:size(self.environment.checkObjects, 2)
                           checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                           if checkCurtain == 1
                              self.environment.robot.stop = 1;
                              break;
                           end
                       end
                   end

                   while (self.environment.robot.stop == 1)
                       disp('Robot Stopped');
                       self.environment.robot.stop = 0;
                       for j = 1:size(self.environment.checkObjects, 2)
                           checkCurtain = self.environment.lightCurtain.CheckLightCurtain(self.environment.checkObjects{i});

                           if checkCurtain == 1
                              self.environment.robot.stop = 1;
                              break;
                           end
                       end
                       pause(0.01);
                   end
                  
                  
                  self.environment.robot.model.base(1, 4) = self.environment.robot.model.base(1,4) + increment;
                  self.environment.robot.model.animate(self.environment.robot.model.getpos);
                  
                  
                  for k = 1:1:size(self.enviroobject, 2)
                    % Set the desired object pose to be at the end effector
                    objectPose = self.model.fkine(self.model.getpos());

                    % Update the object's position
                    self.object(k).SetPose(objectPose);
                  end
                  drawnow();
              end
              disp(3);
           end
        end
       
   end
end